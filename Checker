#!/usr/bin/env python
# coding: utf-8

# In[2]:


import numpy as np
import tensorflow as tf
#import datetime
#from PIL import Image
import glob
import random
import os


# In[11]:


# Функція створення даних для навчання:
def LoadData(fileName):
    data = []
    with open(fileName) as f:
        for line in f:
            t = [float(x) for x in line.split()]
            if t[0]==0 and t[1]==0 and t[2]==0:
                continue
            data.append(t)
    a = np.array( data )
    inData = a[:,0:16]
    outData = a[:,16:24]
    return inData, outData


# In[34]:


inData, outData = LoadData('checkers.txt')
print(inData.shape)
print(outData.shape)


# In[14]:


def write_neyron_to_file(file_, name_, w_, b_):
    width = w_.shape[1]
    height = w_.shape[0]
    file_.write('[')
    for i in range(0, height):
        file_.write('[')
        for j in range(0, width):
            if j!=width-1: file_.write(str(w_[i][j])+', ')
            else: file_.write(str(w_[i][j]))
        file_.write('],\n\r')
    file_.write('[')
    for i in range(0, width):
        if i!=width-1: file_.write(str(b_[i])+', ')
        else: file_.write(str(b_[i]))
    file_.write(']\n\r]')


def write_model_to_file(file_name, w1_, b1_, w2_, b2_, w3_, b3_):
    f = open(file_name, 'wt')
    f.write('[\n\r')
    write_neyron_to_file(file_=f, name_='layer1', w_=sess.run(w1_), b_=sess.run(b1_))
    f.write(',\n\r')
    write_neyron_to_file(file_=f, name_='layer2', w_=sess.run(w2_), b_=sess.run(b2_))
    f.write(',\n\r')
    write_neyron_to_file(file_=f, name_='layer3', w_=sess.run(w3_), b_=sess.run(b3_))
    f.write('\n\r]')
    f.close()


# In[15]:


#Межа ініціалізації випадкових коефіцієнтів нейронів
delta = 0.1


# In[16]:


sess = tf.Session()


# In[17]:


#Визначаємо входи до нейронної мережі. 8 значення радару перешкод та 8 значення радару до суперника
input_count = 16
x_ = tf.placeholder(name="input", shape=[None, input_count], dtype=tf.float32)


# In[18]:


#Визначаємо виходи з нейронної мережі
output_count = 8
y_ = tf.placeholder(name= "output", shape=[None, output_count], dtype=tf.float32)


# In[19]:


#Кількість нейронів першого шару:
layer_count_1 = 16
w1 = tf.Variable(tf.random_uniform(shape=[input_count, layer_count_1], minval=-delta, maxval=delta))
# Зміщення до виходів з нейронів до функції активації, як показала практика, без них гірше
b1 = tf.Variable(tf.constant(value=0.0, shape=[layer_count_1], dtype=tf.float32))
# Визначаємо шар нейронів як послідовність операцій w1*x_+b1
layer1 = tf.nn.relu(tf.add(tf.matmul(x_, w1), b1))


# In[20]:


layer_count_2 = 16
# Визначаємо нейрони прихованого шару
w2 = tf.Variable(tf.random_uniform(shape=[layer_count_1, layer_count_2], minval=-delta, maxval=delta))
# Зміщення для другого шару
b2 =  tf.Variable(tf.constant(value=0.0, shape=[layer_count_2], dtype=tf.float32))
# й w2*вихід1+b2
layer2 = tf.nn.relu(tf.add(tf.matmul(layer1, w2), b2))


# In[21]:


# Формування вихідного шару
w3 = tf.Variable(tf.random_uniform(shape=[layer_count_2 , 8], minval=-delta, maxval=delta))
# Зміщення вихідного шару
b3 =  tf.Variable(tf.constant(value=0.0, shape=[8], dtype=tf.float32))
# w3*вихід2+b3
nn_output = tf.add(tf.matmul(layer2, w3), b3)


# In[22]:


# Ця змінна містить швидкість змін коефіцієнтів нейронної мережі при навчанні
gd = tf.train.GradientDescentOptimizer(0.05)
# Функцією втрат буде среднє квадратів відхилення від заданих величин
loss =  tf.reduce_mean(tf.square(nn_output - y_))
# Тренування проводиться мінімізацією функції втрат
train_step = gd.minimize(loss)


# In[35]:


init_g = tf.global_variables_initializer()
init_l = tf.local_variables_initializer()
sess.run(init_g)
sess.run(init_l)


# In[38]:


step_out = 1000
v_loss = 0
for k in range(1, 10000):
    #r = random.randint(0, inData.shape[0]-1)
    #x = inData[r]
    #x.shape = (1, 64)
    #y = outData[r]
    #y.shape = (1, 3)
    #sess.run(train_step, feed_dict={x_:x, y_:y})
    #v_loss = v_loss + sess.run(loss, feed_dict={x_:x, y_:y})
    sess.run(train_step, feed_dict={x_:inData, y_:outData})
    v_loss = v_loss + sess.run(loss, feed_dict={x_:inData, y_:outData})
    if k % step_out == 0:
        print(k, "  :  ", v_loss/step_out)
        v_loss = 0
write_model_to_file("checkers.json", w1, b1, w2, b2, w3, b3)


# In[39]:


print(sess.run(nn_output, feed_dict={x_:inData, y_:outData}))
